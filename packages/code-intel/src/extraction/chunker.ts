/**
 * Chunker - Code chunking engine for multi-granularity indexing
 *
 * Produces chunks at three levels:
 * 1. Symbol-aligned: Each function/class/method = 1 chunk
 * 2. Block: Sliding window for gaps between symbols
 * 3. File: Full file content (truncated for large files)
 */

import type { ChunkNode, ChunkType, SymbolNode } from "../types";

// ============================================================================
// Configuration
// ============================================================================

export interface ChunkerConfig {
	/** Maximum lines per chunk (default: 50) */
	maxChunkLines: number;
	/** Minimum lines per chunk (default: 5) */
	minChunkLines: number;
	/** Overlap lines between sliding window chunks (default: 3) */
	overlapLines: number;
	/** Maximum chunks per file (default: 100) */
	maxChunksPerFile: number;
	/** Large file threshold in lines (default: 5000) */
	largeFileThreshold: number;
	/** Maximum file content length for file-level chunks (default: 8000 chars) */
	maxFileContentLength: number;
}

export const DEFAULT_CHUNKER_CONFIG: ChunkerConfig = {
	maxChunkLines: 50,
	minChunkLines: 5,
	overlapLines: 3,
	maxChunksPerFile: 100,
	largeFileThreshold: 5000,
	maxFileContentLength: 8000,
};

// ============================================================================
// Chunk ID Generation
// ============================================================================

/**
 * Generate deterministic chunk ID from file path, line range, and content hash
 */
export function generateChunkId(
	filePath: string,
	startLine: number,
	endLine: number,
	contentHash: string,
): string {
	const hasher = new Bun.CryptoHasher("sha256");
	hasher.update(`${filePath}:${startLine}:${endLine}:${contentHash}`);
	return hasher.digest("hex").slice(0, 16);
}

/**
 * Generate content hash for change detection
 */
export function generateContentHash(content: string): string {
	const hasher = new Bun.CryptoHasher("sha256");
	hasher.update(content);
	return hasher.digest("hex").slice(0, 16);
}

// ============================================================================
// Chunker Interface
// ============================================================================

export interface Chunker {
	/**
	 * Extract chunks from a file
	 * @param filePath - Relative file path
	 * @param content - File content
	 * @param symbols - Extracted symbols from the file
	 * @param language - File language
	 * @param branch - Git branch
	 * @returns Array of chunks
	 */
	chunk(
		filePath: string,
		content: string,
		symbols: SymbolNode[],
		language: "typescript" | "python" | "unknown",
		branch: string,
	): ChunkNode[];
}

// ============================================================================
// Chunker Implementation
// ============================================================================

export function createChunker(config: Partial<ChunkerConfig> = {}): Chunker {
	const cfg: ChunkerConfig = { ...DEFAULT_CHUNKER_CONFIG, ...config };

	/**
	 * Check if content looks auto-generated (lockfiles, minified, etc.)
	 */
	function isAutoGenerated(content: string, filePath: string): boolean {
		// Check file patterns
		const autoGeneratedPatterns = [
			/\.lock$/,
			/\.min\.js$/,
			/\.min\.css$/,
			/\.bundle\.js$/,
			/package-lock\.json$/,
			/yarn\.lock$/,
			/pnpm-lock\.yaml$/,
			/\.d\.ts$/,
		];

		if (autoGeneratedPatterns.some((p) => p.test(filePath))) {
			return true;
		}

		// Check content patterns (minified = very long lines)
		const lines = content.split("\n");
		const avgLineLength =
			lines.reduce((sum, line) => sum + line.length, 0) / lines.length;

		// Minified files have very long average line length
		if (avgLineLength > 500) {
			return true;
		}

		// Check for auto-generated headers
		const header = content.slice(0, 500).toLowerCase();
		if (
			header.includes("auto-generated") ||
			header.includes("autogenerated") ||
			header.includes("do not edit")
		) {
			return true;
		}

		return false;
	}

	/**
	 * Create symbol-aligned chunks from extracted symbols
	 */
	function createSymbolChunks(
		filePath: string,
		symbols: SymbolNode[],
		language: "typescript" | "python" | "unknown",
		branch: string,
	): ChunkNode[] {
		const chunks: ChunkNode[] = [];

		for (const symbol of symbols) {
			// Skip external symbols (they have no content)
			if (symbol.is_external || !symbol.content) {
				continue;
			}

			const contentHash = generateContentHash(symbol.content);
			const chunkId = generateChunkId(
				filePath,
				symbol.start_line,
				symbol.end_line,
				contentHash,
			);

			chunks.push({
				id: chunkId,
				file_path: filePath,
				start_line: symbol.start_line,
				end_line: symbol.end_line,
				content: symbol.content,
				chunk_type: "symbol" as ChunkType,
				parent_symbol_id: symbol.id,
				language,
				content_hash: contentHash,
				branch,
				updated_at: Date.now(),
			});
		}

		return chunks;
	}

	/**
	 * Find gaps between symbols that need block chunking
	 */
	function findGaps(
		lines: string[],
		symbols: SymbolNode[],
	): Array<{ startLine: number; endLine: number }> {
		const gaps: Array<{ startLine: number; endLine: number }> = [];

		// Sort symbols by start line
		const sortedSymbols = [...symbols]
			.filter((s) => !s.is_external)
			.sort((a, b) => a.start_line - b.start_line);

		let currentLine = 1;

		for (const symbol of sortedSymbols) {
			// Gap before this symbol
			if (symbol.start_line > currentLine) {
				gaps.push({
					startLine: currentLine,
					endLine: symbol.start_line - 1,
				});
			}
			// Move past this symbol
			currentLine = Math.max(currentLine, symbol.end_line + 1);
		}

		// Gap after last symbol
		if (currentLine <= lines.length) {
			gaps.push({
				startLine: currentLine,
				endLine: lines.length,
			});
		}

		return gaps;
	}

	/**
	 * Create sliding window chunks for gaps between symbols
	 */
	function createBlockChunks(
		filePath: string,
		lines: string[],
		gaps: Array<{ startLine: number; endLine: number }>,
		language: "typescript" | "python" | "unknown",
		branch: string,
	): ChunkNode[] {
		const chunks: ChunkNode[] = [];

		for (const gap of gaps) {
			const gapLines = gap.endLine - gap.startLine + 1;

			// Skip tiny gaps
			if (gapLines < cfg.minChunkLines) {
				continue;
			}

			// Create sliding window chunks
			let startLine = gap.startLine;

			while (startLine <= gap.endLine) {
				const endLine = Math.min(startLine + cfg.maxChunkLines - 1, gap.endLine);
				const chunkLines = lines.slice(startLine - 1, endLine);
				const content = chunkLines.join("\n");

				// Skip empty or whitespace-only chunks
				if (content.trim().length === 0) {
					startLine = endLine + 1;
					continue;
				}

				const contentHash = generateContentHash(content);
				const chunkId = generateChunkId(filePath, startLine, endLine, contentHash);

				chunks.push({
					id: chunkId,
					file_path: filePath,
					start_line: startLine,
					end_line: endLine,
					content,
					chunk_type: "block" as ChunkType,
					parent_symbol_id: undefined,
					language,
					content_hash: contentHash,
					branch,
					updated_at: Date.now(),
				});

				// Move window with overlap
				const nextStartLine = endLine + 1 - cfg.overlapLines;

				// Prevent infinite loop - must always advance
				if (nextStartLine <= startLine) {
					startLine = endLine + 1;
				} else {
					startLine = nextStartLine;
				}
			}
		}

		return chunks;
	}

	/**
	 * Create file-level chunk (truncated for large files)
	 */
	function createFileChunk(
		filePath: string,
		content: string,
		lines: string[],
		language: "typescript" | "python" | "unknown",
		branch: string,
	): ChunkNode | null {
		// Truncate content for large files
		let truncatedContent = content;
		let endLine = lines.length;

		if (content.length > cfg.maxFileContentLength) {
			truncatedContent = content.slice(0, cfg.maxFileContentLength);
			// Find the line count for truncated content
			endLine = truncatedContent.split("\n").length;
		}

		// Skip empty files
		if (truncatedContent.trim().length === 0) {
			return null;
		}

		const contentHash = generateContentHash(truncatedContent);
		const chunkId = generateChunkId(filePath, 1, endLine, contentHash);

		return {
			id: chunkId,
			file_path: filePath,
			start_line: 1,
			end_line: endLine,
			content: truncatedContent,
			chunk_type: "file" as ChunkType,
			parent_symbol_id: undefined,
			language,
			content_hash: contentHash,
			branch,
			updated_at: Date.now(),
		};
	}

	return {
		chunk(
			filePath: string,
			content: string,
			symbols: SymbolNode[],
			language: "typescript" | "python" | "unknown",
			branch: string,
		): ChunkNode[] {
			const lines = content.split("\n");
			const chunks: ChunkNode[] = [];

			// Skip auto-generated files
			if (isAutoGenerated(content, filePath)) {
				// Just create a file-level chunk for reference
				const fileChunk = createFileChunk(filePath, content, lines, language, branch);
				return fileChunk ? [fileChunk] : [];
			}

			// For very large files, prefer symbol-only chunking
			const isLargeFile = lines.length > cfg.largeFileThreshold;

			// 1. Symbol-aligned chunks (always created)
			const symbolChunks = createSymbolChunks(filePath, symbols, language, branch);
			chunks.push(...symbolChunks);

			// 2. Block chunks for gaps (skip for large files)
			if (!isLargeFile) {
				const gaps = findGaps(lines, symbols);
				const blockChunks = createBlockChunks(filePath, lines, gaps, language, branch);
				chunks.push(...blockChunks);
			}

			// 3. File-level chunk (for file-level search)
			const fileChunk = createFileChunk(filePath, content, lines, language, branch);
			if (fileChunk) {
				chunks.push(fileChunk);
			}

			// Cap total chunks per file
			if (chunks.length > cfg.maxChunksPerFile) {
				// Prioritize: symbol chunks > file chunk > block chunks
				const symbolChunksOnly = chunks.filter((c) => c.chunk_type === "symbol");
				const fileChunks = chunks.filter((c) => c.chunk_type === "file");
				const blockChunksOnly = chunks.filter((c) => c.chunk_type === "block");

				const remaining = cfg.maxChunksPerFile - symbolChunksOnly.length - fileChunks.length;
				const selectedBlockChunks = blockChunksOnly.slice(0, Math.max(0, remaining));

				return [...symbolChunksOnly, ...fileChunks, ...selectedBlockChunks];
			}

			return chunks;
		},
	};
}
